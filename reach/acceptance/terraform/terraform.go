package terraform

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"testing"
)

const terraformPlan = "terraform.plan"

type terraform struct {
	t        *testing.T
	execPath string
	tempDir  string
	logging  bool
}

// New creates a new instance of a terraform struct that can perform the operations of a basic Terraform workflow.
// Callers should call CleanUp() when done with the object to ensure there are no lingering side effects.
func New(t *testing.T, logging bool) *terraform {
	t.Helper()

	const execName = "terraform"

	// make sure we have access to terraform executable
	execPath, err := exec.LookPath(execName)
	if err != nil {
		t.Fatalf("unable to find %s: %v", execName, err)
	}
	if logging {
		t.Logf("found %s at: %s", execName, execPath)
	}

	// create temporary working directory for all Terraform operations
	tempDir, err := ioutil.TempDir("", "terraform")
	if err != nil {
		t.Fatalf("unable to create temp dir: %v", err)
	}
	if logging {
		t.Logf("created temporary working directory for terraform files: %s", tempDir)
	}

	return &terraform{
		t:        t,
		execPath: execPath,
		tempDir:  tempDir,
		logging:  logging,
	}
}

func (tf *terraform) CleanUp() {
	tf.t.Helper()

	err := os.RemoveAll(tf.tempDir)
	if tf.logging {
		if err != nil {
			tf.t.Logf("unable to clean up temp dir '%s': %v", tf.tempDir, err)
		} else {
			tf.t.Logf("temp dir was successfully removed ('%s')", tf.tempDir)
		}
	}
}

// Load copies files for Terraform to use into the temporary working directory.
// It is recommended that callers pass in absolute file paths, since the terraform object occasionally needs to change the working directory.
func (tf *terraform) Load(files ...string) {
	tf.t.Helper()

	if tf.logging {
		cwd, err := os.Getwd()
		if err != nil {
			tf.t.Logf("unable to determine current working dir")
		} else {
			tf.t.Logf("about to look for files... (working dir is: %s)", cwd)
		}
	}

	for _, file := range files {
		if tf.logging {
			tf.t.Logf("loading '%s'...", file)
		}
		data, err := ioutil.ReadFile(file)
		if err != nil {
			tf.t.Fatalf("unable to read file '%s': %v", file, err)
		}

		_, filename := path.Split(file)
		destFile := path.Join(tf.tempDir, filename)
		err = ioutil.WriteFile(destFile, data, 0644)
		if err != nil {
			tf.t.Fatalf("unable to write file '%s': %v", destFile, err)
		}
	}
}

// Init calls 'terraform init' to initialize Terraform in the temporary working directory.
func (tf *terraform) Init() {
	tf.t.Helper()

	tf.action("unable to initialize terraform", "init")
}

// Plan calls 'terraform plan' to create a Terraform plan that can be run by calling Apply().
func (tf *terraform) Plan() {
	tf.t.Helper()

	tf.action("unable to create plan", "plan", "-out", terraformPlan)
}

// Apply calls 'terraform apply', which applies the plan generated by calling Plan(). This means you must first call Plan().
func (tf *terraform) Apply() {
	tf.t.Helper()

	tf.action("unable to apply plan", "apply", terraformPlan)
}

// Destroy calls 'terraform destroy' non-interactively, which tears down all resources referenced within the temp dir.
func (tf *terraform) Destroy() {
	tf.t.Helper()

	tf.action("unable to destroy", "destroy", "-auto-approve")
}

func (tf *terraform) Output(name string) string {
	tf.t.Helper()

	pop := tf.changeToTempDir()
	defer pop()

	output, err := tf.execForOutput("output", "-no-color", name)
	if err != nil {
		tf.t.Fatalf("unable to retrieve output '%s': %v", name, err)
	}

	return output
}

// Version retrieves the current Terraform version by calling 'terraform version'.
func (tf *terraform) Version() string {
	tf.t.Helper()

	b, err := tf.execForOutput("version")
	if err != nil && tf.logging {
		tf.t.Logf("unable to get version: %v", err)
	}

	return string(b)
}

func (tf *terraform) action(errMessage string, args ...string) {
	tf.t.Helper()

	pop := tf.changeToTempDir()
	defer pop()

	err := tf.exec(args...)
	if err != nil {
		tf.t.Fatalf("%s: %v", errMessage, err)
	}
}

func (tf *terraform) changeToTempDir() func() {
	tf.t.Helper()

	originalWorkDir, err := os.Getwd()
	if err != nil {
		tf.t.Fatalf("unable to determine original working directory: %v", err)
	}

	err = os.Chdir(tf.tempDir)
	if err != nil {
		tf.t.Fatalf("unable to change directory to '%s': %v", tf.tempDir, err)
	}

	changeToOriginalDir := func() {
		err = os.Chdir(originalWorkDir)
		if err != nil {
			tf.t.Fatalf("unable to change directory to '%s': %v", originalWorkDir, err)
		}
	}

	return changeToOriginalDir
}

func (tf *terraform) exec(args ...string) error {
	tf.t.Helper()

	cmd := exec.Command(tf.execPath, args...)

	var stdout, stderr io.ReadCloser

	if tf.logging {
		var err error
		stdout, err = cmd.StdoutPipe()
		if err != nil {
			return err
		}
		stderr, err = cmd.StderrPipe()
		if err != nil {
			return err
		}
	}

	err := cmd.Start()
	if err != nil {
		return err
	}

	if tf.logging {
		multi := io.MultiReader(stdout, stderr)
		in := bufio.NewScanner(multi)

		for in.Scan() {
			fmt.Printf("%v\n", in.Text())
		}
		if err := in.Err(); err != nil {
			fmt.Printf("error: %s", err)
		}
	}

	return nil
}

func (tf *terraform) execForOutput(args ...string) (string, error) {
	tf.t.Helper()

	cmd := exec.Command(tf.execPath, args...)

	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return "", fmt.Errorf("unable to connect to stdout: %v", err)
	}
	stderr, err := cmd.StderrPipe()
	if err != nil {
		return "", fmt.Errorf("unable to connect to stderr: %v", err)
	}

	err = cmd.Start()
	if err != nil {
		return "", fmt.Errorf("unable to start command: %v", err)
	}

	fromStdout := bufio.NewScanner(stdout)
	fromStderr := bufio.NewScanner(stderr)

	var output string
	for fromStdout.Scan() {
		output += fmt.Sprintf("%s\n", fromStdout.Text())
	}

	var errText string
	for fromStderr.Scan() {
		errText += fmt.Sprintf("%s\n", fromStderr.Text())
	}

	err = cmd.Wait()
	if err != nil {
		return "", fmt.Errorf("command exited non-zero: %v\n\n%s\n", err, errText)
	}

	return output, nil
}
